<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
        
        
        <link rel="shortcut icon" href="../../img/favicon.ico">

	<title>FEniCS101 - hIPPYlib</title>

        <link href="../../css/bootstrap-custom.min.css" rel="stylesheet">
        <link href="../../css/font-awesome-4.0.3.css" rel="stylesheet">
        <link rel="stylesheet" href="../../css/highlight.css">
        <link href="../../css/base.css" rel="stylesheet">

        <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
        <!--[if lt IE 9]>
            <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
            <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
        <![endif]-->

        
        <script>
            (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
            (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
            m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
            })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

            ga('create', 'UA-52448613-3', 'hippylib.github.io');
            ga('send', 'pageview');
        </script>
        
    </head>

    <body>

        <div class="navbar navbar-default navbar-fixed-top" role="navigation">
    <div class="container">

        <!-- Collapsed navigation -->
        <div class="navbar-header">
            <!-- Expander button -->
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>

            <!-- Main title -->
            <a class="navbar-brand" href="../..">hIPPYlib</a>
        </div>

        <!-- Expanded navigation -->
        <div class="navbar-collapse collapse">
            <!-- Main navigation -->
            <ul class="nav navbar-nav">
            
            
                <li >
                    <a href="../..">Home</a>
                </li>
            
            
            
                <li class="dropdown active">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">Tutorial <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                        <li >
                            <a href="../../tutorial/">README</a>
                        </li>
                    
                        <li class="active">
                            <a href="./">FEniCS101</a>
                        </li>
                    
                        <li >
                            <a href="../2_PoissonDeterministic/">Poisson Deterministic</a>
                        </li>
                    
                        <li >
                            <a href="../3_SubsurfaceBayesian/">Subsurface Bayesian</a>
                        </li>
                    
                        <li >
                            <a href="../4_AdvectionDiffusionBayesian/">Advection-Diffusion Bayesian</a>
                        </li>
                    
                        <li >
                            <a href="../5_HessianSpectrum/">Hessian Spectrum</a>
                        </li>
                    
                    </ul>
                </li>
            
            
            
                <li >
                    <a href="../../building/">Installation</a>
                </li>
            
            
            
                <li >
                    <a href="../../download/">Download</a>
                </li>
            
            
            
                <li >
                    <a href="../../research/">Research</a>
                </li>
            
            
            
                <li >
                    <a href="../../outreach/">Outreach</a>
                </li>
            
            
            
                <li >
                    <a href="../../about/">About</a>
                </li>
            
            
            </ul>

            <!-- Search, Navigation and Repo links -->
            <ul class="nav navbar-nav navbar-right">
                <li >
                    <a rel="next" href="../../tutorial/">
                        <i class="fa fa-arrow-left"></i> Previous
                    </a>
                </li>
                <li >
                    <a rel="prev" href="../2_PoissonDeterministic/">
                        Next <i class="fa fa-arrow-right"></i>
                    </a>
                </li>
                
                <li>
                    <a href="https://github.com/hippylib/hippylib">
                        
                            <i class="fa fa-github"></i>
                        
                        GitHub
                    </a>
                </li>
                
            </ul>
        </div>
    </div>
</div>

        <div class="container">
            <div class="col-md-3"><div class="bs-sidebar hidden-print affix well" role="complementary">
    <ul class="nav bs-sidenav">
    
        <li class="main active"><a href="#fenics101-tutorial">FEniCS101 Tutorial</a></li>
        
            <li><a href="#weak-formulation">Weak formulation</a></li>
        
            <li><a href="#1-load-modules">1. Load modules</a></li>
        
            <li><a href="#2-define-the-mesh-and-the-finite-element-space">2. Define the mesh and the finite element space</a></li>
        
            <li><a href="#3-define-boundary-labels">3. Define boundary labels</a></li>
        
            <li><a href="#4-define-the-coefficients-of-the-pde-and-the-boundary-conditions">4. Define the coefficients of the PDE and the boundary conditions</a></li>
        
            <li><a href="#5-define-and-solve-the-variational-problem">5. Define and solve the variational problem</a></li>
        
            <li><a href="#6-compute-the-discretization-error">6. Compute the discretization error</a></li>
        
            <li><a href="#7-convergence-of-the-finite-element-method">7. Convergence of the finite element method</a></li>
        
    
    </ul>
</div></div>
            <div class="col-md-9" role="main">

<h1 id="fenics101-tutorial">FEniCS101 Tutorial</h1>
<p>In this tutorial we consider the boundary value problem (BVP)</p>
<p>
<script type="math/tex; mode=display">\begin{eqnarray*}
- \nabla \cdot (k \nabla u) = f &      \text{ in } \Omega,\\
u = u_0 & \text{ on } \Gamma_D = \Gamma_{\rm left} \bigcup \Gamma_{\rm right},\\
k \frac{\partial u}{\partial {\bf{n}}} = \sigma & \text{ on } \Gamma_N = \Gamma_{\rm top} \bigcup \Gamma_{\rm bottom},
\end{eqnarray*}</script>
</p>
<p>where <script type="math/tex"> \Omega = (0,1) \times (0,1) </script>, <script type="math/tex"> \Gamma_D </script> and and <script type="math/tex"> \Gamma_N </script> are the union of
the left and right, and top and bottom boundaries of <script type="math/tex"> \Omega </script>,
respectively.</p>
<p>Here
<script type="math/tex; mode=display">\begin{eqnarray*}
k(x,y) = 1  & \text{ on } \Omega\\
f(x,y) = \left(4\pi^2+\frac{\pi^2}{4}\right)\sin(2 \pi x) \sin\left(\frac{\pi}{2} y\right) & \text{ on } \Omega\\
u_0(x,y)      = 0 & \text{ on } \Gamma_D, \\
\sigma(x) = \left\{ \begin{array}{l} -\frac{\pi}{2}\sin(2 \pi x) \\ 0 \end{array}\right.
& \begin{array}{l} \text{ on } \Gamma_{\rm bottom},\\ \text{ on } \Gamma_{\rm top}.\end{array}
\end{eqnarray*}</script>
</p>
<p>The exact solution is
<script type="math/tex; mode=display"> u_e(x,y) = \sin(2\pi x)\sin\left(\frac{\pi}{2}y\right). </script>
</p>
<h2 id="weak-formulation">Weak formulation</h2>
<p>Let us define the Hilbert spaces <script type="math/tex"> V_{u_0}, V_0 \in \Omega </script> as
<script type="math/tex; mode=display"> V_{u_0} := \left\{ v \in H^1(\Omega) \text{ s. t. } v = u_0 \text{ on } \Gamma_D \right\},</script>
<script type="math/tex; mode=display"> V_{0} := \left\{ v \in H^1(\Omega) \text{ s. t. } v = 0 \text{ on } \Gamma_D \right\}.</script>
</p>
<p>To obtain the weak formulation, we multiply the PDE by an arbitrary function <script type="math/tex"> v \in V_0 </script> and integrate over the domain <script type="math/tex">\Omega </script> leading to</p>
<p>
<script type="math/tex; mode=display"> -\int_{\Omega} \nabla \cdot (k \nabla u) v \, dx = \int_\Omega f v \, dx\quad \forall \; v \in V_0. </script>
</p>
<p>Then, integration by parts the non-conforming term gives</p>
<p>
<script type="math/tex; mode=display"> \int_{\Omega} k \nabla u \cdot \nabla v \, dx - \int_{\partial \Omega} k \frac{\partial u}{\partial {\bf n} } v \, ds = \int_\Omega f v \, dx \quad \forall \; v \in V_0. </script>
</p>
<p>Finally by recalling that <script type="math/tex"> v = 0 </script> on <script type="math/tex"> \Gamma_D </script> and that <script type="math/tex"> k \frac{\partial u}{\partial {\bf n} } = \sigma </script> on <script type="math/tex">\Gamma_N </script>, we find the weak formulation:</p>
<p><em>Find</em> <script type="math/tex"> u \in V_{u_0}</script>
<em>such that</em>
<script type="math/tex; mode=display"> \int_{\Omega} k \nabla u \cdot \nabla v \, dx = \int_\Omega f v \, dx + \int_{\Gamma_N} \sigma v \, ds \quad \forall \; v \in V_0. </script>
</p>
<h2 id="1-load-modules">1. Load modules</h2>
<p>To start we load the following modules:</p>
<ul>
<li>
<p>dolfin: the python/C++ interface to FEniCS</p>
</li>
<li>
<p><a href="https://docs.python.org/2/library/math.html">math</a>: the python module for mathematical functions</p>
</li>
<li>
<p><a href="http://www.numpy.org/">numpy</a>: a python package for linear algebra</p>
</li>
<li>
<p><a href="http://matplotlib.org/">matplotlib</a>: a python package used for plotting the results</p>
</li>
</ul>
<pre><code>from dolfin import *

import math
import numpy as np
import logging

import matplotlib.pyplot as plt
%matplotlib inline
import nb

logging.getLogger('FFC').setLevel(logging.WARNING)
logging.getLogger('UFL').setLevel(logging.WARNING)
set_log_active(False)
</code></pre>

<h2 id="2-define-the-mesh-and-the-finite-element-space">2. Define the mesh and the finite element space</h2>
<p>We construct a triangulation (mesh) <script type="math/tex"> \mathcal{T}_h </script> of the computational domain <script type="math/tex"> \Omega := [0, 1]^2 </script> with <code>n</code> elements in each direction.</p>
<p>On the mesh <script type="math/tex"> \mathcal{T}_h </script>, we then define the finite element space <script type="math/tex"> V_h \subset H^1(\Omega) </script> consisting of globally continuous piecewise polinomials functions. The <code>degree</code> variable defines the polinomial degree.</p>
<pre><code>n = 16
degree = 1
mesh = RectangleMesh(0, 0, 1, 1, n, n)
nb.plot(mesh)

Vh  = FunctionSpace(mesh, 'Lagrange', degree)
print &quot;dim(Vh) = &quot;, Vh.dim()
</code></pre>

<pre><code>dim(Vh) =  289
</code></pre>
<p><img alt="png" src="./output_4_1.png" /></p>
<h2 id="3-define-boundary-labels">3. Define boundary labels</h2>
<p>To partition the boundary of <script type="math/tex">\Omega</script> in the subdomains <script type="math/tex">\Gamma_{\rm top}</script>, <script type="math/tex">\Gamma_{\rm bottom}</script>, <script type="math/tex">\Gamma_{\rm left}</script>, <script type="math/tex">\Gamma_{\rm right}</script> we assign a unique label <code>boundary_parts</code> to each of part of <script type="math/tex"> \partial \Omega</script>.</p>
<pre><code>class TopBoundary(SubDomain):
    def inside(self, x, on_boundary):
        return on_boundary and abs(x[1] - 1) &lt; DOLFIN_EPS

class BottomBoundary(SubDomain):
    def inside(self, x, on_boundary):
        return on_boundary and abs(x[1]) &lt; DOLFIN_EPS

class LeftBoundary(SubDomain):
    def inside(self, x, on_boundary):
        return on_boundary and abs(x[0]) &lt; DOLFIN_EPS

class RightBoundary(SubDomain):
    def inside(self, x, on_boundary):
        return on_boundary and abs(x[0] - 1) &lt; DOLFIN_EPS

boundary_parts = FacetFunction(&quot;size_t&quot;, mesh)
boundary_parts.set_all(0)

Gamma_top = TopBoundary()
Gamma_top.mark(boundary_parts, 1)
Gamma_bottom = BottomBoundary()
Gamma_bottom.mark(boundary_parts, 2)
Gamma_left = LeftBoundary()
Gamma_left.mark(boundary_parts, 3)
Gamma_right = RightBoundary()
Gamma_right.mark(boundary_parts, 4)
</code></pre>

<h2 id="4-define-the-coefficients-of-the-pde-and-the-boundary-conditions">4. Define the coefficients of the PDE and the boundary conditions</h2>
<p>We first define the coefficients of the PDE using the <code>Constant</code> and <code>Expression</code> classes. <code>Constant</code> is used to define coefficients that do not depend on the space coordinates, <code>Expression</code> is used to define coefficients that are a known function of the space coordinates <code>x[0]</code> (x-axis direction) and <code>x[1]</code> (y-axis direction).</p>
<p>In the finite element method community, Dirichlet boundary conditions are also known as <em>essential</em> boundary conditions since they are imposed directly in the definition of the finite element space. In FEniCS, we use the class <code>DirichletBC</code> to indicate this type of condition.</p>
<p>On the other hand, Newman boundary conditions are also known as <em>natural</em> boundary conditions since they are weakly imposed as boundary integrals in the variational formulation (weak form). In FEniCS, we create a new boundary measure <code>ds[i]</code> to integrate over the portion of the boundary marked with label <code>i</code>.</p>
<pre><code>u_L = Constant(0.)
u_R = Constant(0.)

sigma_bottom = Expression('-(pi/2.0)*sin(2*pi*x[0])')
sigma_top    = Expression('0')

f = Expression('(4.0*pi*pi+pi*pi/4.0)*(sin(2*pi*x[0])*sin((pi/2.0)*x[1]))')

bcs = [DirichletBC(Vh, u_L, boundary_parts, 3),
       DirichletBC(Vh, u_R, boundary_parts, 4)]

ds = Measure(&quot;ds&quot;, subdomain_data=boundary_parts)
</code></pre>

<h2 id="5-define-and-solve-the-variational-problem">5. Define and solve the variational problem</h2>
<p>We also define two special types of functions: the <code>TrialFunction</code> <code>u</code> and the <code>TestFunction</code> <code>v</code>. These special types of function are used by <code>FEniCS</code> to generate the finite element vectors and matrices which stem from the weak formulation of the PDE.</p>
<p>More specifically, by denoting by <script type="math/tex">\left[{\phi_i(x)}\right]_{i=1}^{{\rm dim}(V_h)}</script> the finite element basis for the space <script type="math/tex">V_h</script>, a function <script type="math/tex"> u_h \in V_h</script> can be written as
<script type="math/tex; mode=display"> u_h = \sum_{i=1}^{{\rm dim}(V_h)} {\rm u}_i \phi_i(x), </script>
where <script type="math/tex">{\rm u}_i</script> represents the coefficients in the finite element expansion of <script type="math/tex">u_h</script>.</p>
<p>We then define</p>
<ul>
<li>
<p>the bilinear form <script type="math/tex"> a(u_h, v_h) = \int_\Omega \nabla u_h \cdot \nabla v_h dx </script>;</p>
</li>
<li>
<p>the linear form <script type="math/tex"> L(v_h) = \int_\Omega f v_h dx + \int_{\Gamma_{\rm top}} \sigma_{\rm top} v_h ds + \int_{\Gamma_{\rm bottom}} \sigma_{\rm bottom} v_h ds</script>.</p>
</li>
</ul>
<p>We can then solve the variational problem</p>
<p><em>Find</em> <script type="math/tex"> u_h \in V_h</script>
<em>such that</em>
<script type="math/tex; mode=display"> a(u_h, v_h) = L(v_h) \quad \forall\, v_h \in V_h </script>
</p>
<p>using directly the built-in <code>solve</code> method in FEniCS.</p>
<p><strong>NOTE:</strong> As an alternative one can also assemble the finite element matrix <script type="math/tex"> A </script> and the right hand side <script type="math/tex"> b </script> that stems from the discretization of <script type="math/tex"> a </script> and <script type="math/tex"> L </script>, and then solve the linear system
<script type="math/tex; mode=display"> A {\rm u} = {\rm b}, </script>
where</p>
<ul>
<li>
<p>
<script type="math/tex"> {\rm u} </script> is the vector collecting the coefficient of the finite element expasion of <script type="math/tex"> u_h </script>,</p>
</li>
<li>
<p>the entries of the matrix A are such that <script type="math/tex"> A_{ij} = a(\phi_j, \phi_i) </script>,</p>
</li>
<li>
<p>the entries of the right hand side b are such that <script type="math/tex"> b_i = L(\phi_i) </script>.</p>
</li>
</ul>
<pre><code>u = TrialFunction(Vh)
v = TestFunction(Vh)
a = inner(nabla_grad(u), nabla_grad(v))*dx
L = f*v*dx + sigma_top*v*ds(1) + sigma_bottom*v*ds(2)

uh = Function(Vh)

#solve(a == L, uh, bcs=bcs)
A, b = assemble_system(a,L, bcs=bcs)
solve(A, uh.vector(), b, &quot;cg&quot;)

nb.plot(uh)
</code></pre>

<p><img alt="png" src="./output_10_1.png" /></p>
<h2 id="6-compute-the-discretization-error">6. Compute the discretization error</h2>
<p>For this problem, the exact solution is known.
We can therefore compute the following norms of the discretization error (i.e. the of the difference between the finite element solution <script type="math/tex"> u_h </script> and the exact solution <script type="math/tex"> u_{\rm ex} </script>)
<script type="math/tex; mode=display"> \| u_{\rm ex} - u_h \|_{L^2{\Omega}} := \sqrt{ \int_{\Omega} (u_{\rm ex} - u_h)^2 \, dx }, </script> 
and
<script type="math/tex; mode=display"> \| u_{\rm ex} - u_h \|_{H^1{\Omega}} := \sqrt{ \int_{\Omega} (u_{\rm ex} - u_h)^2 \, dx + \int_{\Omega} |\nabla u_{\rm ex} - \nabla u_h|^2 \, dx}. </script>
</p>
<pre><code>u_e = Expression('sin(2*pi*x[0])*sin((pi/2.0)*x[1])')
grad_u_e = Expression( ('2*pi*cos(2*pi*x[0])*sin((pi/2.0)*x[1])', 'pi/2.0*sin(2*pi*x[0])*cos((pi/2.0)*x[1])'))

err_L2 = sqrt( assemble( (uh-u_e)**2*dx ) )
err_grad = sqrt( assemble( inner(nabla_grad(uh) - grad_u_e, nabla_grad(uh) - grad_u_e)*dx ) )
err_H1 = sqrt( err_L2**2 + err_grad**2)

print &quot;|| u_h - u_e ||_L2 = &quot;, err_L2
print &quot;|| u_h - u_e ||_H1 = &quot;, err_H1
</code></pre>

<pre><code>|| u_h - u_e ||_L2 =  0.00842388144799
|| u_h - u_e ||_H1 =  0.394127114471
</code></pre>
<h2 id="7-convergence-of-the-finite-element-method">7. Convergence of the finite element method</h2>
<p>We now verify numerically a well-known convergence result for the finite element method.</p>
<p>Let denote with <script type="math/tex"> s </script> the polynomial degree of the finite element space, and assume that the solution <script type="math/tex"> u_{\rm ex}</script> is at least in <script type="math/tex"> H^{s+1}(\Omega) </script>. Then we have
<script type="math/tex; mode=display"> \| u_{\rm ex} - u_h \|_{H^1} \leq C h^{s}, \quad \| u_{\rm ex} - u_h \|_{L^2} \leq C h^{s+1}. </script>
</p>
<p>In the code below, the function <code>compute(n, degree)</code> solves the PDE using a mesh with <code>n</code> elements in each direction and finite element spaces of polinomial order <code>degree</code>.</p>
<p>The figure below shows the discretization errors in the <script type="math/tex"> H^1 </script> and <script type="math/tex"> L^2 </script> as a function of the mesh size <script type="math/tex"> h </script> ( <script type="math/tex"> h = \frac{1}{n}</script> ) for piecewise linear (P1, <script type="math/tex"> s=1 </script> ) and piecewise quadratic (P2, <script type="math/tex">s=2</script> ) finite elements. We observe that numerical results are consistent with the finite element convergence theory. In particular:</p>
<ul>
<li>
<p>for piecewise linear finite element P1 we observe first order convergence in the <script type="math/tex"> H^1</script>-norm and second order convergence in the <script type="math/tex"> L^2</script>-norm;</p>
</li>
<li>
<p>for piecewise quadratic finite element P2 we observe second order convergence in the <script type="math/tex"> H^1</script>-norm and third order convergence in the <script type="math/tex"> L^2</script>-norm.</p>
</li>
</ul>
<pre><code>def compute(n, degree):
    mesh = RectangleMesh(0, 0, 1, 1, n, n)
    Vh  = FunctionSpace(mesh, 'Lagrange', degree)
    boundary_parts = FacetFunction(&quot;size_t&quot;, mesh)
    boundary_parts.set_all(0)

    Gamma_top = TopBoundary()
    Gamma_top.mark(boundary_parts, 1)
    Gamma_bottom = BottomBoundary()
    Gamma_bottom.mark(boundary_parts, 2)
    Gamma_left = LeftBoundary()
    Gamma_left.mark(boundary_parts, 3)
    Gamma_right = RightBoundary()
    Gamma_right.mark(boundary_parts, 4)

    bcs = [DirichletBC(Vh, u_L, boundary_parts, 3), DirichletBC(Vh, u_R, boundary_parts, 4)]
    ds = Measure(&quot;ds&quot;, subdomain_data=boundary_parts)

    u = TrialFunction(Vh)
    v = TestFunction(Vh)
    a = inner(nabla_grad(u), nabla_grad(v))*dx
    L = f*v*dx + sigma_top*v*ds(1) + sigma_bottom*v*ds(2)
    uh = Function(Vh)
    solve(a == L, uh, bcs=bcs)
    err_L2 = sqrt( assemble( (uh-u_e)**2*dx ) )
    err_grad = sqrt( assemble( inner(nabla_grad(uh) - grad_u_e, nabla_grad(uh) - grad_u_e)*dx ) )
    err_H1 = sqrt( err_L2**2 + err_grad**2)

    return err_L2, err_H1

nref = 5
n = 8*np.power(2,np.arange(0,nref))
h = 1./n

err_L2_P1 = np.zeros(nref)
err_H1_P1 = np.zeros(nref)
err_L2_P2 = np.zeros(nref)
err_H1_P2 = np.zeros(nref)

for i in range(nref):
    err_L2_P1[i], err_H1_P1[i] = compute(n[i], 1)
    err_L2_P2[i], err_H1_P2[i] = compute(n[i], 2)

plt.figure(figsize=(15,5))

plt.subplot(121)
plt.loglog(h, err_H1_P1, '-or')
plt.loglog(h, err_L2_P1, '-*b')
plt.loglog(h, h*.5*err_H1_P1[0]/h[0], '--g')
plt.loglog(h, np.power(h,2)*.5*np.power( err_L2_P1[0]/h[0], 2), '-.k')
plt.xlabel(&quot;Mesh size h&quot;)
plt.ylabel(&quot;Error&quot;)
plt.title(&quot;P1 Finite Element&quot;)
plt.legend([&quot;H1 error&quot;, &quot;L2 error&quot;, &quot;First Order&quot;, &quot;Second Order&quot;], 'lower right')


plt.subplot(122)
plt.loglog(h, err_H1_P2, '-or')
plt.loglog(h, err_L2_P2, '-*b')
plt.loglog(h, np.power(h/h[0],2)*.5*err_H1_P2[0], '--g')
plt.loglog(h, np.power(h/h[0],3)*.5*err_L2_P2[0], '-.k')
plt.xlabel(&quot;Mesh size h&quot;)
plt.ylabel(&quot;Error&quot;)
plt.title(&quot;P2 Finite Element&quot;)
plt.legend([&quot;H1 error&quot;, &quot;L2 error&quot;, &quot;Second Order&quot;, &quot;Third Order&quot;], 'lower right')

plt.show()
</code></pre>

<p><img alt="png" src="./output_14_0.png" /></p>
<p>Copyright (c) 2016, The University of Texas at Austin &amp; University of California, Merced.
All Rights reserved.
See file COPYRIGHT for details.</p>
<p>This file is part of the hIPPYlib library. For more information and source code
availability see https://hippylib.github.io.</p>
<p>hIPPYlib is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License (as published by the Free Software Foundation) version 3.0 dated June 2007.</p></div>
        </div>

        <footer class="col-md-12">
            <hr>
            
            <center>Documentation built with <a href="http://www.mkdocs.org/">MkDocs</a>.</center>
        </footer>

        <script src="../../js/jquery-1.10.2.min.js"></script>
        <script src="../../js/bootstrap-3.0.3.min.js"></script>
        <script src="../../js/highlight.pack.js"></script>
        <script src="../../js/base.js"></script>
        <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </body>
</html>